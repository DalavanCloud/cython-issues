{
    "assignee": null,
    "assignees": [],
    "author_association": "NONE",
    "body": "As some of you might know, [Stackless Python](https://github.com/stackless-dev/stackless) is an old and venerable fork of regular C-Python. Stackless Python enhances C-Python and modifies the core of the interpreter in a way, that can't be done as an extension module. But otherwise Stackless Python is fully API and ABI compatible with the corresponding C-Python version, for instance you can replace C-Python 3.6.4 with Stackless Python 3.6.4 and everything should continue to work. This works well, except for Cython modules, because Cython uses undocumented implementation details of C-Python. Additionally there is [Stackless bug 166](https://github.com/stackless-dev/stackless/issues/166), which is already fixed for Stackless 2.7 and will soon be fixed for 3.x.\r\n\r\nCurrently, I know of the following problems: \r\n\r\n### PyMethodDef ml_flags\r\n\r\nIn Cython/Utility/ModuleSetupCode.c and Cython/Utility/ObjectHandling.c Cython uses `METH_xxx`-flags but ignores `METH_STACKLESS`. Probably this affects Stackless 3.6 and 3.7 and is is trivial to fix. I'll create a pull request.\r\n\r\n### Incompatible PyFrameObject\r\n\r\nCython uses fields of `PyFameObject`, which are documented to be subject to change at any time. Unfortunately Stackless has a different `PyFrameObject`. Let's compare them:\r\n\r\nC-Python:\r\n```\r\ntypedef struct _frame {\r\n    PyObject_VAR_HEAD\r\n    struct _frame *f_back;      /* previous frame, or NULL */\r\n    PyCodeObject *f_code;       /* code segment */\r\n    ... other fields\r\n    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */\r\n    PyObject *f_localsplus[1];  /* locals+stack, dynamically sized */\r\n} PyFrameObject;\r\n```\r\n\r\nStackless Python:\r\n```\r\ntypedef struct _frame {\r\n    PyObject_VAR_HEAD\r\n    struct _frame *f_back;      /* previous frame, or NULL */\r\n    PyFrame_ExecFunc *f_execute;/* support for soft stackless */\r\n    ... other fields, identical to C-Python\r\n    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */\r\n    PyCodeObject *f_code;           /* code segment */\r\n    PyObject *f_localsplus[1];  /* locals+stack, dynamically sized */\r\n} PyFrameObject;\r\n```\r\n\r\nAs you can see, Stackless has an additional field `f_execute`. And the following fields have a different offset: `f_code` and `f_localsplus`. This makes `__Pyx_PyFunction_FastCallNoKw()` ABI incompatible between C-Python and Stackless, because this function [uses `f_localsplus`](https://github.com/cython/cython/blob/df3efb3e5f39968b3ceaf68e7fa06b5c20e71806/Cython/Utility/ObjectHandling.c#L1966). This is fatal, because it breaks compatibility to binary wheels, which are almost always compiled using C-Python. How can we resolve this incompatibility? Currently I see three options:\r\n\r\n1. Change Cython to use only documented API. Not realistic for performance reasons.\r\n\r\n2. Change Cython to determinate the offset of `f_localsplus` at runtime. Probably the most clean solution. It is possible to compute the offset of `f_localsplus` from the size of a frame (`Py_SIZE(f)`) and the information in the code object. Of course the offset is constant at run time and may be cached.\r\n\r\n3. Change Stackless to detect and \"repair\" a corrupted `PyFrameObject`. This would require a change to the layout of the Stackless `PyFrameObject` first, because currently Stackless `f_code` gets overwritten, when `__Pyx_PyFunction_FastCallNoKw()` writes `f_localsplus[0]`. Once `f_code` is preserved, Stackless can shift the `f_localsplus` array to the correct offset. It could work, but it would be an ugly hack, that relies on Cython implementation details. The advantage is, that it restores the compatibility with already existing Cython based extension modules.\r\n\r\nPerhaps there are better options.\r\n",
    "closed_at": null,
    "comment_data": [],
    "comments": 0,
    "comments_url": "https://api.github.com/repos/cython/cython/issues/2534/comments",
    "created_at": "2018-08-06T22:58:56Z",
    "event_data": [],
    "events_url": "https://api.github.com/repos/cython/cython/issues/2534/events",
    "html_url": "https://github.com/cython/cython/issues/2534",
    "id": 348109382,
    "labels": [],
    "labels_url": "https://api.github.com/repos/cython/cython/issues/2534/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "MDU6SXNzdWUzNDgxMDkzODI=",
    "number": 2534,
    "repository_url": "https://api.github.com/repos/cython/cython",
    "state": "open",
    "title": "Compatibility with Stackless Python",
    "updated_at": "2018-08-06T22:58:56Z",
    "url": "https://api.github.com/repos/cython/cython/issues/2534",
    "user": {
        "avatar_url": "https://avatars1.githubusercontent.com/u/659726?v=4",
        "events_url": "https://api.github.com/users/akruis/events{/privacy}",
        "followers_url": "https://api.github.com/users/akruis/followers",
        "following_url": "https://api.github.com/users/akruis/following{/other_user}",
        "gists_url": "https://api.github.com/users/akruis/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/akruis",
        "id": 659726,
        "login": "akruis",
        "node_id": "MDQ6VXNlcjY1OTcyNg==",
        "organizations_url": "https://api.github.com/users/akruis/orgs",
        "received_events_url": "https://api.github.com/users/akruis/received_events",
        "repos_url": "https://api.github.com/users/akruis/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/akruis/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/akruis/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/akruis"
    }
}