{
    "assignee": null,
    "assignees": [],
    "body": "Consider the following class in C++.  Note that the class is not copy constructable as it contains a managed pointer.  The constructor of the function may throw an exception.\r\n````cpp\r\n#pragma once\r\n#include <iostream>\r\n#include <memory>\r\n\r\nclass TestClass\r\n{\r\npublic:\r\n  std::unique_ptr<int> i;\r\n\r\n  TestClass() : i(new int) {};\r\n\r\n  TestClass(int i_) : i(new int)\r\n  {\r\n    if ( i_ == 0 )\r\n      throw 0;\r\n    *i = i_;\r\n  }\r\n};\r\n\r\ninline void cpp_function(TestClass t)\r\n{\r\n  std::cout << *(t.i) << \"\\n\";\r\n}\r\n````\r\n\r\nThis exception should be propagated to Cython, which should be possible via `except +`.\r\n````python\r\ncdef extern from \"test.hpp\":\r\n    cppclass TestClass:\r\n        TestClass(int) except +\r\n\r\n    void cpp_function(TestClass t)\r\n        \r\ndef interface(i):\r\n     cpp_function(TestClass(i))\r\n````\r\n\r\nUnfortunately, the generated code cannot be compiled.  Let’s take a look why.  The relevant part is this (shortened) bit:\r\n````cpp\r\nstatic PyObject *__pyx_pf_4test_interface(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_i) {\r\n  /* ... some more stuff ... */\r\n  TestClass __pyx_t_2;\r\n  __Pyx_RefNannySetupContext(\"interface\", 0);\r\n\r\n  /* \"test.pyx\":8\r\n * \r\n * def interface(i):\r\n *      cpp_function(TestClass(i))             # <<<<<<<<<<<<<<\r\n */\r\n  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_i); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L1_error)\r\n  try {\r\n    __pyx_t_2 = TestClass(__pyx_t_1);\r\n  } catch(...) {\r\n    __Pyx_CppExn2PyErr();\r\n    __PYX_ERR(0, 8, __pyx_L1_error)\r\n  }\r\n  cpp_function(__pyx_t_2);\r\n  /* ... some more stuff ... */\r\n}\r\n````\r\n\r\nFirst of all we notice the line\r\n````cpp\r\nTestClass __pyx_t_2;\r\n````\r\nwhich implies that the object is default constructable.  If not, the code will not compile.  A meaningless default constructor can in most cases be achieved but puts some additional bookkeeping work on the C++ programmer’s shoulders.  This is also an issue but can be circumvented.\r\n\r\nMore crucial is the line\r\n````cpp\r\ncpp_function(__pyx_t_2);\r\n````\r\nwhere the object is attempted to be copied.  This is not possible as the object is not copyable.  The code does not compile, because `error: use of deleted function ‘TestClass::TestClass(const TestClass&)’`.\r\n\r\nWith C++11 this situation can be handled though, simply using\r\n````cpp\r\ncpp_function(std::move(__pyx_t_2));\r\n````\r\nIn case that the object can be moved this is done, otherwise it is copied nevertheless.\r\n\r\n**Please add `std::move` to function calls.**\r\n\r\n---\r\n\r\n*Addendum:*\r\n\r\nIt would be best to use a pointer for the object to be created in combination with the move.  This way it does neither need to be default constructable nor copyable.\r\n\r\n````cpp\r\nstatic PyObject *__pyx_pf_4test_interface(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_i) {\r\n  /* ... some more stuff ... */\r\n  std::unique_ptr<TestClass> __pyx_t_2;\r\n  __Pyx_RefNannySetupContext(\"interface\", 0);\r\n\r\n  /* \"test.pyx\":8\r\n * \r\n * def interface(i):\r\n *      cpp_function(TestClass(i))             # <<<<<<<<<<<<<<\r\n */\r\n  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_i); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L1_error)\r\n  try {\r\n    __pyx_t_2.reset(new TestClass(__pyx_t_1));\r\n  } catch(...) {\r\n    __Pyx_CppExn2PyErr();\r\n    __PYX_ERR(0, 8, __pyx_L1_error)\r\n  }\r\n  cpp_function(std::move(*__pyx_t_2));\r\n  /* ... some more stuff ... */\r\n}\r\n````",
    "closed_at": null,
    "comment_data": [],
    "comments": 0,
    "comments_url": "https://api.github.com/repos/cython/cython/issues/1612/comments",
    "created_at": "2017-02-23T12:57:47Z",
    "event_data": [],
    "events_url": "https://api.github.com/repos/cython/cython/issues/1612/events",
    "html_url": "https://github.com/cython/cython/issues/1612",
    "id": 209754185,
    "labels": [],
    "labels_url": "https://api.github.com/repos/cython/cython/issues/1612/labels{/name}",
    "locked": false,
    "milestone": null,
    "number": 1612,
    "repository_url": "https://api.github.com/repos/cython/cython",
    "state": "open",
    "title": "Move arguments instead of copy",
    "updated_at": "2017-02-23T13:04:53Z",
    "url": "https://api.github.com/repos/cython/cython/issues/1612",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/1903556?v=3",
        "events_url": "https://api.github.com/users/hmenke/events{/privacy}",
        "followers_url": "https://api.github.com/users/hmenke/followers",
        "following_url": "https://api.github.com/users/hmenke/following{/other_user}",
        "gists_url": "https://api.github.com/users/hmenke/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/hmenke",
        "id": 1903556,
        "login": "hmenke",
        "organizations_url": "https://api.github.com/users/hmenke/orgs",
        "received_events_url": "https://api.github.com/users/hmenke/received_events",
        "repos_url": "https://api.github.com/users/hmenke/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/hmenke/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/hmenke/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/hmenke"
    }
}